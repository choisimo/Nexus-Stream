# Team Collaboration Service Development Plan

## ê°œìš”
Corporate Nexus Streamì˜ íŒ€ í˜‘ì—… ë° ì»¤ë®¤ë‹ˆì¼€ì´ì…˜ í”Œë«í¼ìœ¼ë¡œ, ì¡°ì§ ë‚´ íŒ€ì›ë“¤ ê°„ì˜ íš¨ê³¼ì ì¸ ì†Œí†µ, í˜‘ì—…, ì§€ì‹ ê³µìœ ë¥¼ ì§€ì›í•˜ëŠ” í†µí•© ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.

## ì£¼ìš” ê¸°ëŠ¥

### 1. ì‹¤ì‹œê°„ ì»¤ë®¤ë‹ˆì¼€ì´ì…˜
- **ì¸ìŠ¤í„´íŠ¸ ë©”ì‹œì§•**: 1:1 ë° ê·¸ë£¹ ì±„íŒ…
- **íŒŒì¼ ê³µìœ **: ë¬¸ì„œ, ì´ë¯¸ì§€, ì½”ë“œ ë“± ë‹¤ì–‘í•œ íŒŒì¼ ê³µìœ 
- **í™”ë©´ ê³µìœ **: ì‹¤ì‹œê°„ í™”ë©´ ê³µìœ  ë° ì›ê²© ì§€ì›
- **ìŒì„±/ì˜ìƒ í†µí™”**: WebRTC ê¸°ë°˜ ê³ í’ˆì§ˆ í†µí™”
- **ìƒíƒœ í‘œì‹œ**: ì˜¨ë¼ì¸, ë¶€ì¬ì¤‘, íšŒì˜ ì¤‘ ë“± ìƒíƒœ ê´€ë¦¬

### 2. íŒ€ ì›Œí¬ìŠ¤í˜ì´ìŠ¤
- **ì±„ë„ ê´€ë¦¬**: ì£¼ì œë³„, í”„ë¡œì íŠ¸ë³„ ì±„ë„ êµ¬ì„±
- **ìŠ¤ë ˆë“œ ê¸°ëŠ¥**: ëŒ€í™”ì˜ ë§¥ë½ì„ ìœ ì§€í•˜ëŠ” ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œ
- **ë©˜ì…˜ ì‹œìŠ¤í…œ**: @ë©˜ì…˜ì„ í†µí•œ íŠ¹ì • ì‚¬ìš©ì ì•Œë¦¼
- **ì´ëª¨ì§€ ë°˜ì‘**: ë¹ ë¥¸ í”¼ë“œë°±ì„ ìœ„í•œ ì´ëª¨ì§€ ë°˜ì‘
- **ë©”ì‹œì§€ ê²€ìƒ‰**: ê³¼ê±° ëŒ€í™” ë‚´ìš© ê²€ìƒ‰ ë° ì°¾ê¸°

### 3. í™”ìƒ íšŒì˜
- **íšŒì˜ì‹¤ ì˜ˆì•½**: ê°€ìƒ íšŒì˜ì‹¤ ì˜ˆì•½ ë° ê´€ë¦¬
- **íšŒì˜ ë…¹í™”**: ìë™ íšŒì˜ ë…¹í™” ë° ì €ì¥
- **í™”ë©´ ê³µìœ **: í”„ë ˆì  í…Œì´ì…˜ ë° ìë£Œ ê³µìœ 
- **í™”ì´íŠ¸ë³´ë“œ**: ì‹¤ì‹œê°„ í˜‘ì—… í™”ì´íŠ¸ë³´ë“œ
- **íšŒì˜ë¡**: AI ê¸°ë°˜ ìë™ íšŒì˜ë¡ ìƒì„±

### 4. í”„ë¡œì íŠ¸ í˜‘ì—…
- **ì‘ì—… ê³µê°„**: í”„ë¡œì íŠ¸ë³„ ì „ìš© í˜‘ì—… ê³µê°„
- **ë¬¸ì„œ í˜‘ì—…**: ì‹¤ì‹œê°„ ë¬¸ì„œ ê³µë™ í¸ì§‘
- **ì½”ë“œ ë¦¬ë·°**: ì½”ë“œ ë³€ê²½ì‚¬í•­ ë¦¬ë·° ë° í† ë¡ 
- **ì´ìŠˆ ì¶”ì **: ë²„ê·¸, ê°œì„ ì‚¬í•­ ì¶”ì  ë° ê´€ë¦¬
- **ì§„í–‰ ìƒí™© ê³µìœ **: ì‘ì—… ì§„ì²™ë„ ì‹¤ì‹œê°„ ê³µìœ 

### 5. ì§€ì‹ ê³µìœ 
- **Q&A í”Œë«í¼**: ì§ˆë¬¸ê³¼ ë‹µë³€ ê²Œì‹œíŒ
- **ì „ë¬¸ê°€ ë„¤íŠ¸ì›Œí¬**: ë¶„ì•¼ë³„ ì „ë¬¸ê°€ ì—°ê²°
- **ìœ„í‚¤ ì‹œìŠ¤í…œ**: íŒ€ ì§€ì‹ ë² ì´ìŠ¤ êµ¬ì¶•
- **íŠœí† ë¦¬ì–¼**: ë‹¨ê³„ë³„ ê°€ì´ë“œ ë° íŠœí† ë¦¬ì–¼
- **ê²½í—˜ ê³µìœ **: ì„±ê³µ/ì‹¤íŒ¨ ì‚¬ë¡€ ê³µìœ 

## ê¸°ìˆ  ìŠ¤íƒ

### Frontend
- **Framework**: React 18 + TypeScript
- **Real-time**: Socket.io Client
- **UI Components**: Radix UI + shadcn/ui
- **State Management**: Zustand + TanStack Query
- **Rich Editor**: Slate.js ë˜ëŠ” ProseMirror
- **WebRTC**: Simple-peer, PeerJS

### Backend
- **API Framework**: Node.js + Socket.io
- **Database**: PostgreSQL + Redis
- **Message Queue**: RabbitMQ ë˜ëŠ” Apache Kafka
- **File Storage**: MinIO ë˜ëŠ” AWS S3
- **Media Server**: Kurento, Janus, ë˜ëŠ” mediasoup
- **Search**: Elasticsearch

### Real-time Infrastructure
- **WebSocket**: Socket.io
- **WebRTC Signaling**: Socket.io
- **TURN/STUN Server**: Coturn
- **Media Processing**: FFmpeg
- **Push Notifications**: FCM, APNs

### AI/ML Services
- **Speech-to-Text**: Google Speech API, Whisper
- **Natural Language**: GPT-4, spaCy
- **Translation**: Google Translate API
- **Sentiment Analysis**: ìì²´ êµ¬ì¶• ëª¨ë¸

## ë°ì´í„° ëª¨ë¸

### Team Workspace Schema
```sql
CREATE TABLE workspaces (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    avatar_url TEXT,
    
    -- Organization
    organization_id UUID REFERENCES organizations(id),
    
    -- Settings
    is_public BOOLEAN DEFAULT FALSE,
    allow_external_invites BOOLEAN DEFAULT FALSE,
    retention_days INTEGER DEFAULT 365,
    
    -- Status
    status VARCHAR(20) DEFAULT 'active', -- active, archived, suspended
    
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE workspace_members (
    id UUID PRIMARY KEY,
    workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    
    -- Role and Permissions
    role VARCHAR(50) DEFAULT 'member', -- owner, admin, member, guest
    permissions JSONB DEFAULT '{}',
    
    -- Status
    status VARCHAR(20) DEFAULT 'active', -- active, inactive, invited
    invited_by UUID REFERENCES users(id),
    
    -- Timestamps
    joined_at TIMESTAMP DEFAULT NOW(),
    last_seen_at TIMESTAMP,
    
    UNIQUE(workspace_id, user_id)
);
```

### Channel and Message Schema
```sql
CREATE TABLE channels (
    id UUID PRIMARY KEY,
    workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Channel Type
    type VARCHAR(20) DEFAULT 'public', -- public, private, direct, group
    
    -- Settings
    is_archived BOOLEAN DEFAULT FALSE,
    is_default BOOLEAN DEFAULT FALSE,
    thread_enabled BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- Constraints
    UNIQUE(workspace_id, name)
);

CREATE TABLE messages (
    id UUID PRIMARY KEY,
    channel_id UUID REFERENCES channels(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    
    -- Message Content
    content TEXT NOT NULL,
    content_type VARCHAR(20) DEFAULT 'text', -- text, file, image, code, system
    formatted_content JSONB, -- rich text formatting
    
    -- Threading
    parent_message_id UUID REFERENCES messages(id),
    thread_reply_count INTEGER DEFAULT 0,
    
    -- Attachments
    attachments JSONB DEFAULT '[]',
    
    -- Reactions
    reactions JSONB DEFAULT '{}', -- {"ğŸ‘": ["user1", "user2"], "â¤ï¸": ["user3"]}
    
    -- Message Status
    is_edited BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,
    is_pinned BOOLEAN DEFAULT FALSE,
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

-- Index for message retrieval
CREATE INDEX idx_messages_channel_time ON messages (channel_id, created_at DESC);
CREATE INDEX idx_messages_thread ON messages (parent_message_id, created_at);
```

### Meeting and Call Schema
```sql
CREATE TABLE meetings (
    id UUID PRIMARY KEY,
    workspace_id UUID REFERENCES workspaces(id),
    channel_id UUID REFERENCES channels(id),
    
    -- Meeting Details
    title VARCHAR(255) NOT NULL,
    description TEXT,
    agenda JSONB,
    
    -- Scheduling
    scheduled_start TIMESTAMP,
    scheduled_end TIMESTAMP,
    actual_start TIMESTAMP,
    actual_end TIMESTAMP,
    
    -- Meeting Type
    type VARCHAR(20) DEFAULT 'video', -- video, audio, screen_share
    max_participants INTEGER DEFAULT 50,
    
    -- Recording
    is_recorded BOOLEAN DEFAULT FALSE,
    recording_url TEXT,
    recording_duration INTEGER, -- seconds
    
    -- Status
    status VARCHAR(20) DEFAULT 'scheduled', -- scheduled, active, ended, cancelled
    
    -- Organizer
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE meeting_participants (
    id UUID PRIMARY KEY,
    meeting_id UUID REFERENCES meetings(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id),
    
    -- Participation
    role VARCHAR(20) DEFAULT 'participant', -- host, moderator, participant
    joined_at TIMESTAMP,
    left_at TIMESTAMP,
    duration_seconds INTEGER,
    
    -- Status during meeting
    audio_enabled BOOLEAN DEFAULT TRUE,
    video_enabled BOOLEAN DEFAULT TRUE,
    screen_sharing BOOLEAN DEFAULT FALSE,
    
    UNIQUE(meeting_id, user_id)
);

CREATE TABLE call_logs (
    id UUID PRIMARY KEY,
    meeting_id UUID REFERENCES meetings(id),
    
    -- Call Quality Metrics
    duration_seconds INTEGER,
    audio_quality DECIMAL(3,2), -- 1-5 scale
    video_quality DECIMAL(3,2), -- 1-5 scale
    connection_quality DECIMAL(3,2), -- 1-5 scale
    
    -- Technical Details
    bandwidth_used INTEGER, -- KB
    packet_loss DECIMAL(5,4),
    latency_ms INTEGER,
    
    -- Participant Count
    peak_participants INTEGER,
    average_participants DECIMAL(4,2),
    
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Collaboration Schema
```sql
CREATE TABLE collaborative_documents (
    id UUID PRIMARY KEY,
    workspace_id UUID REFERENCES workspaces(id),
    channel_id UUID REFERENCES channels(id),
    
    -- Document Details
    title VARCHAR(255) NOT NULL,
    content JSONB, -- document content in structured format
    content_type VARCHAR(50) DEFAULT 'markdown', -- markdown, rich_text, code
    
    -- Version Control
    version INTEGER DEFAULT 1,
    
    -- Permissions
    is_public BOOLEAN DEFAULT FALSE,
    edit_permissions JSONB DEFAULT '[]', -- user IDs with edit access
    view_permissions JSONB DEFAULT '[]', -- user IDs with view access
    
    -- Metadata
    created_by UUID REFERENCES users(id),
    last_edited_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE document_revisions (
    id UUID PRIMARY KEY,
    document_id UUID REFERENCES collaborative_documents(id) ON DELETE CASCADE,
    
    -- Revision Details
    version INTEGER NOT NULL,
    content_diff JSONB, -- changes made in this revision
    summary TEXT, -- brief description of changes
    
    -- Author
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(document_id, version)
);

CREATE TABLE document_comments (
    id UUID PRIMARY KEY,
    document_id UUID REFERENCES collaborative_documents(id) ON DELETE CASCADE,
    
    -- Comment Details
    content TEXT NOT NULL,
    selection_range JSONB, -- text selection this comment refers to
    
    -- Threading
    parent_comment_id UUID REFERENCES document_comments(id),
    
    -- Status
    is_resolved BOOLEAN DEFAULT FALSE,
    resolved_by UUID REFERENCES users(id),
    resolved_at TIMESTAMP,
    
    -- Author
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);
```

## API ì„¤ê³„

### Real-time Messaging API
```typescript
// WebSocket Events for Real-time Communication
interface MessageEvents {
  // Send message
  'message:send': {
    channelId: string;
    content: string;
    contentType?: 'text' | 'file' | 'image' | 'code';
    parentMessageId?: string;
    attachments?: FileAttachment[];
  };
  
  // Receive message
  'message:receive': {
    message: Message;
    channel: Channel;
  };
  
  // Typing indicators
  'typing:start': { channelId: string; userId: string };
  'typing:stop': { channelId: string; userId: string };
  
  // Reactions
  'reaction:add': { messageId: string; emoji: string };
  'reaction:remove': { messageId: string; emoji: string };
  
  // User presence
  'presence:update': { userId: string; status: 'online' | 'away' | 'busy' | 'offline' };
}

// REST API for Message Management
interface MessagingAPI {
  // GET /api/channels/:id/messages - ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
  getMessages(channelId: string, params: {
    limit?: number;
    before?: string; // message ID
    after?: string;
    search?: string;
  }): Promise<{
    messages: Message[];
    hasMore: boolean;
    total: number;
  }>;
  
  // PUT /api/messages/:id - ë©”ì‹œì§€ ìˆ˜ì •
  updateMessage(messageId: string, data: {
    content: string;
    attachments?: FileAttachment[];
  }): Promise<Message>;
  
  // DELETE /api/messages/:id - ë©”ì‹œì§€ ì‚­ì œ
  deleteMessage(messageId: string): Promise<void>;
  
  // POST /api/messages/:id/pin - ë©”ì‹œì§€ ê³ ì •
  pinMessage(messageId: string): Promise<void>;
}
```

### Video Conferencing API
```typescript
// Meeting Management API
interface MeetingAPI {
  // POST /api/meetings - íšŒì˜ ìƒì„±
  createMeeting(data: {
    title: string;
    description?: string;
    scheduledStart?: string;
    scheduledEnd?: string;
    channelId?: string;
    participants?: string[]; // user IDs
    isRecorded?: boolean;
    maxParticipants?: number;
  }): Promise<Meeting>;
  
  // GET /api/meetings/:id/join - íšŒì˜ ì°¸ê°€ ì •ë³´
  joinMeeting(meetingId: string): Promise<{
    meeting: Meeting;
    webrtcConfig: {
      iceServers: RTCIceServer[];
      constraints: MediaStreamConstraints;
    };
    token: string; // JWT token for signaling
  }>;
  
  // POST /api/meetings/:id/recording/start - ë…¹í™” ì‹œì‘
  startRecording(meetingId: string): Promise<{
    recordingId: string;
    status: 'starting' | 'active';
  }>;
  
  // POST /api/meetings/:id/recording/stop - ë…¹í™” ì¤‘ì§€
  stopRecording(meetingId: string): Promise<{
    recordingUrl: string;
    duration: number;
    size: number;
  }>;
}

// WebRTC Signaling Events
interface SignalingEvents {
  // Join meeting
  'meeting:join': {
    meetingId: string;
    userId: string;
    userInfo: { name: string; avatar?: string };
  };
  
  // Leave meeting
  'meeting:leave': { meetingId: string; userId: string };
  
  // WebRTC Signaling
  'webrtc:offer': { to: string; offer: RTCSessionDescriptionInit };
  'webrtc:answer': { to: string; answer: RTCSessionDescriptionInit };
  'webrtc:ice-candidate': { to: string; candidate: RTCIceCandidateInit };
  
  // Media controls
  'media:toggle-audio': { userId: string; enabled: boolean };
  'media:toggle-video': { userId: string; enabled: boolean };
  'media:screen-share': { userId: string; sharing: boolean };
}
```

### Collaboration API
```typescript
// Document Collaboration API
interface CollaborationAPI {
  // POST /api/documents - ìƒˆ ë¬¸ì„œ ìƒì„±
  createDocument(data: {
    title: string;
    content?: any;
    contentType?: 'markdown' | 'rich_text' | 'code';
    channelId?: string;
    isPublic?: boolean;
    editPermissions?: string[]; // user IDs
  }): Promise<CollaborativeDocument>;
  
  // GET /api/documents/:id - ë¬¸ì„œ ì¡°íšŒ
  getDocument(documentId: string): Promise<{
    document: CollaborativeDocument;
    activeEditors: {
      userId: string;
      userName: string;
      cursor?: { line: number; column: number };
      selection?: { start: number; end: number };
    }[];
    comments: DocumentComment[];
  }>;
  
  // POST /api/documents/:id/comments - ëŒ“ê¸€ ì¶”ê°€
  addComment(documentId: string, data: {
    content: string;
    selectionRange?: { start: number; end: number };
    parentCommentId?: string;
  }): Promise<DocumentComment>;
  
  // GET /api/documents/:id/revisions - ë¬¸ì„œ íˆìŠ¤í† ë¦¬
  getDocumentRevisions(documentId: string): Promise<{
    revisions: DocumentRevision[];
    canRevert: boolean;
  }>;
}

// Real-time Document Events
interface DocumentEvents {
  // Document editing
  'document:edit': {
    documentId: string;
    userId: string;
    operation: {
      type: 'insert' | 'delete' | 'format';
      position: number;
      content?: string;
      attributes?: any;
    };
  };
  
  // Cursor movement
  'document:cursor': {
    documentId: string;
    userId: string;
    position: { line: number; column: number };
  };
  
  // Comments
  'document:comment': {
    documentId: string;
    comment: DocumentComment;
  };
}
```

### Team Management API
```typescript
// Workspace Management API
interface WorkspaceAPI {
  // POST /api/workspaces - ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ìƒì„±
  createWorkspace(data: {
    name: string;
    description?: string;
    isPublic?: boolean;
    allowExternalInvites?: boolean;
  }): Promise<Workspace>;
  
  // GET /api/workspaces/:id/members - ë©¤ë²„ ëª©ë¡
  getMembers(workspaceId: string, params?: {
    role?: string;
    status?: 'active' | 'inactive' | 'invited';
    search?: string;
  }): Promise<{
    members: WorkspaceMember[];
    total: number;
  }>;
  
  // POST /api/workspaces/:id/invite - ë©¤ë²„ ì´ˆëŒ€
  inviteMembers(workspaceId: string, data: {
    emails: string[];
    role?: 'admin' | 'member' | 'guest';
    message?: string;
  }): Promise<{
    sent: string[];
    failed: { email: string; reason: string }[];
  }>;
  
  // PUT /api/workspaces/:id/members/:userId - ë©¤ë²„ ì—­í•  ë³€ê²½
  updateMemberRole(
    workspaceId: string, 
    userId: string, 
    data: { role: string; permissions?: any }
  ): Promise<WorkspaceMember>;
}

// Channel Management API
interface ChannelAPI {
  // POST /api/workspaces/:id/channels - ì±„ë„ ìƒì„±
  createChannel(workspaceId: string, data: {
    name: string;
    description?: string;
    type?: 'public' | 'private';
    members?: string[]; // for private channels
  }): Promise<Channel>;
  
  // GET /api/channels/:id/info - ì±„ë„ ì •ë³´
  getChannelInfo(channelId: string): Promise<{
    channel: Channel;
    members: ChannelMember[];
    pinnedMessages: Message[];
    statistics: {
      totalMessages: number;
      activeMembers: number;
      lastActivity: string;
    };
  }>;
  
  // POST /api/channels/:id/members - ì±„ë„ ë©¤ë²„ ì¶”ê°€
  addChannelMembers(channelId: string, data: {
    userIds: string[];
  }): Promise<void>;
}
```

## ì‹¤ì‹œê°„ ê¸°ëŠ¥ êµ¬í˜„

### WebSocket ì—°ê²° ê´€ë¦¬
```typescript
class CollaborationSocketManager {
  private io: SocketIOServer;
  private userSessions: Map<string, Set<string>> = new Map();
  
  constructor(server: any) {
    this.io = new SocketIOServer(server, {
      cors: { origin: "*" },
      transports: ["websocket", "polling"]
    });
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      this.handleUserConnection(socket);
      this.setupMessageHandlers(socket);
      this.setupMeetingHandlers(socket);
      this.setupDocumentHandlers(socket);
    });
  }
  
  private handleUserConnection(socket: SocketIOSocket) {
    const userId = socket.handshake.auth.userId;
    
    // Track user sessions
    if (!this.userSessions.has(userId)) {
      this.userSessions.set(userId, new Set());
    }
    this.userSessions.get(userId)!.add(socket.id);
    
    // Join user's workspaces
    this.joinUserWorkspaces(socket, userId);
    
    // Broadcast user online status
    this.broadcastPresence(userId, 'online');
    
    socket.on('disconnect', () => {
      this.handleUserDisconnection(socket, userId);
    });
  }
  
  private setupMessageHandlers(socket: SocketIOSocket) {
    socket.on('message:send', async (data) => {
      try {
        const message = await this.createMessage(data);
        
        // Broadcast to channel members
        socket.to(`channel:${data.channelId}`).emit('message:receive', {
          message,
          channel: await this.getChannel(data.channelId)
        });
        
        // Send push notifications
        await this.sendPushNotifications(message);
      } catch (error) {
        socket.emit('error', { type: 'message_send_failed', error });
      }
    });
    
    socket.on('typing:start', (data) => {
      socket.to(`channel:${data.channelId}`).emit('typing:start', {
        channelId: data.channelId,
        userId: socket.handshake.auth.userId
      });
    });
    
    socket.on('typing:stop', (data) => {
      socket.to(`channel:${data.channelId}`).emit('typing:stop', {
        channelId: data.channelId,
        userId: socket.handshake.auth.userId
      });
    });
  }
}
```

### WebRTC ì‹œê·¸ë„ë§ ì„œë²„
```typescript
class WebRTCSignalingServer {
  private io: SocketIOServer;
  private activeMeetings: Map<string, Set<string>> = new Map();
  
  constructor(io: SocketIOServer) {
    this.io = io;
    this.setupSignalingHandlers();
  }
  
  private setupSignalingHandlers() {
    this.io.on('connection', (socket) => {
      socket.on('meeting:join', async (data) => {
        const { meetingId, userId } = data;
        
        // Add user to meeting
        if (!this.activeMeetings.has(meetingId)) {
          this.activeMeetings.set(meetingId, new Set());
        }
        this.activeMeetings.get(meetingId)!.add(socket.id);
        
        // Join meeting room
        await socket.join(`meeting:${meetingId}`);
        
        // Notify existing participants
        socket.to(`meeting:${meetingId}`).emit('participant:joined', {
          userId,
          userInfo: data.userInfo
        });
        
        // Send current participants to new user
        const participants = await this.getMeetingParticipants(meetingId);
        socket.emit('meeting:participants', participants);
      });
      
      socket.on('webrtc:offer', (data) => {
        socket.to(data.to).emit('webrtc:offer', {
          from: socket.id,
          offer: data.offer
        });
      });
      
      socket.on('webrtc:answer', (data) => {
        socket.to(data.to).emit('webrtc:answer', {
          from: socket.id,
          answer: data.answer
        });
      });
      
      socket.on('webrtc:ice-candidate', (data) => {
        socket.to(data.to).emit('webrtc:ice-candidate', {
          from: socket.id,
          candidate: data.candidate
        });
      });
      
      socket.on('media:toggle-audio', (data) => {
        socket.broadcast.emit('participant:audio-toggle', {
          userId: socket.handshake.auth.userId,
          enabled: data.enabled
        });
      });
    });
  }
  
  private async getMeetingParticipants(meetingId: string) {
    // Fetch participants from database
    // Return participant info for WebRTC connection setup
  }
}
```

## êµ¬í˜„ ë‹¨ê³„

### Phase 1: ê¸°ë³¸ ë©”ì‹œì§• ì‹œìŠ¤í…œ (8ì£¼)
- [ ] ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë° ì±„ë„ ê´€ë¦¬
- [ ] ì‹¤ì‹œê°„ ë©”ì‹œì§• (í…ìŠ¤íŠ¸)
- [ ] íŒŒì¼ ì—…ë¡œë“œ ë° ê³µìœ 
- [ ] ì‚¬ìš©ì ì˜¨ë¼ì¸ ìƒíƒœ
- [ ] ê¸°ë³¸ ëª¨ë°”ì¼ ì§€ì›

### Phase 2: ê³ ê¸‰ ë©”ì‹œì§• ê¸°ëŠ¥ (6ì£¼)
- [ ] ë©”ì‹œì§€ ìŠ¤ë ˆë“œ ë° ë°˜ì‘
- [ ] ë¦¬ì¹˜ í…ìŠ¤íŠ¸ ì—ë””í„°
- [ ] ë©”ì‹œì§€ ê²€ìƒ‰ ë° í•„í„°ë§
- [ ] ë©˜ì…˜ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ
- [ ] ì´ëª¨ì§€ ë° GIF ì§€ì›

### Phase 3: í™”ìƒ íšŒì˜ ì‹œìŠ¤í…œ (12ì£¼)
- [ ] WebRTC ê¸°ë°˜ P2P í†µí™”
- [ ] ë‹¤ìê°„ í™”ìƒ íšŒì˜
- [ ] í™”ë©´ ê³µìœ  ê¸°ëŠ¥
- [ ] íšŒì˜ ë…¹í™” ë° ì¬ìƒ
- [ ] ê°€ìƒ ë°°ê²½ ë° í•„í„°

### Phase 4: í˜‘ì—… ë„êµ¬ (10ì£¼)
- [ ] ì‹¤ì‹œê°„ ë¬¸ì„œ í¸ì§‘
- [ ] ê³µìœ  í™”ì´íŠ¸ë³´ë“œ
- [ ] ì½”ë“œ ë¦¬ë·° ì‹œìŠ¤í…œ
- [ ] íˆ¬í‘œ ë° ì„¤ë¬¸ ë„êµ¬
- [ ] í”„ë¡œì íŠ¸ ì¹¸ë°˜ ë³´ë“œ

### Phase 5: AI ê¸°ë°˜ ê¸°ëŠ¥ (8ì£¼)
- [ ] ìë™ íšŒì˜ë¡ ìƒì„±
- [ ] ë©”ì‹œì§€ ìš”ì•½ ë° ë²ˆì—­
- [ ] ìŠ¤ë§ˆíŠ¸ ì•Œë¦¼ í•„í„°ë§
- [ ] ê°ì • ë¶„ì„ ë° ì¸ì‚¬ì´íŠ¸
- [ ] ì±—ë´‡ í†µí•©

### Phase 6: ê³ ê¸‰ í†µí•© ë° ìµœì í™” (6ì£¼)
- [ ] ì™¸ë¶€ ë„êµ¬ í†µí•© (Slack, Teams, etc.)
- [ ] ê³ ê¸‰ ë³´ì•ˆ ê¸°ëŠ¥
- [ ] ì„±ëŠ¥ ìµœì í™”
- [ ] ëª¨ë°”ì¼ ì•± ì™„ì„±
- [ ] ì ‘ê·¼ì„± ê°œì„ 

## ì„±ëŠ¥ ìµœì í™”

### ì‹¤ì‹œê°„ í†µì‹  ìµœì í™”
- **Connection Pooling**: WebSocket ì—°ê²° í’€ë§
- **Message Batching**: ë©”ì‹œì§€ ë°°ì¹˜ ì²˜ë¦¬
- **Compression**: ë©”ì‹œì§€ ì••ì¶• ì „ì†¡
- **CDN í™œìš©**: ì •ì  ìì‚° CDN ë°°í¬

### í™•ì¥ì„± ì„¤ê³„
- **ìˆ˜í‰ í™•ì¥**: Redis Adapter ê¸°ë°˜ Socket.io í´ëŸ¬ìŠ¤í„°ë§
- **ë¡œë“œ ë°¸ëŸ°ì‹±**: Sticky Session ê¸°ë°˜ ë¡œë“œ ë°¸ëŸ°ì‹±
- **ë°ì´í„°ë² ì´ìŠ¤ ìƒ¤ë”©**: ì±„ë„ë³„ ë°ì´í„° ë¶„ì‚°
- **ë¯¸ë””ì–´ ì„œë²„**: ì „ìš© ë¯¸ë””ì–´ ì„œë²„ í´ëŸ¬ìŠ¤í„°

## ë³´ì•ˆ ë° í”„ë¼ì´ë²„ì‹œ

### ë°ì´í„° ë³´ì•ˆ
- **End-to-End ì•”í˜¸í™”**: ë¯¼ê°í•œ ëŒ€í™” ë‚´ìš© E2E ì•”í˜¸í™”
- **ë©”ì‹œì§€ ë³´ì¡´**: ë²•ì  ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ë°ì´í„° ë³´ì¡´
- **ì ‘ê·¼ ì œì–´**: ì±„ë„ë³„ ì„¸ë°€í•œ ê¶Œí•œ ê´€ë¦¬
- **ê°ì‚¬ ë¡œê·¸**: ëª¨ë“  ì¤‘ìš” í™œë™ ê¸°ë¡

### ì»´í”Œë¼ì´ì–¸ìŠ¤
- **GDPR ì¤€ìˆ˜**: ê°œì¸ì •ë³´ ë³´í˜¸ ê·œì • ì¤€ìˆ˜
- **SOC 2**: ë³´ì•ˆ ì œì–´ í‘œì¤€ ì¤€ìˆ˜
- **ISO 27001**: ì •ë³´ë³´ì•ˆ ê´€ë¦¬ í‘œì¤€
- **HIPAA**: ì˜ë£Œ ì •ë³´ ë³´ì•ˆ (í•„ìš”ì‹œ)

## ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„

### ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ì—°ê²° ìƒíƒœ**: WebSocket ì—°ê²° ìˆ˜ ë° ìƒíƒœ
- **ë©”ì‹œì§€ ì²˜ë¦¬ëŸ‰**: ì´ˆë‹¹ ë©”ì‹œì§€ ì²˜ë¦¬ ìˆ˜
- **í™”ìƒ íšŒì˜ í’ˆì§ˆ**: ì˜ìƒ/ìŒì„± í’ˆì§ˆ ì§€í‘œ
- **ì—ëŸ¬ìœ¨**: ì‹¤íŒ¨í•œ ì‘ì—… ë¹„ìœ¨

### ì‚¬ìš©ì ë¶„ì„
- **ì°¸ì—¬ë„**: ì‚¬ìš©ìë³„ í™œë™ ìˆ˜ì¤€
- **ì±„ë„ í™œì„±ë„**: ì±„ë„ë³„ ë©”ì‹œì§€ ë¹ˆë„
- **íšŒì˜ í†µê³„**: íšŒì˜ ì‹œê°„, ì°¸ê°€ì ìˆ˜ ë“±
- **í˜‘ì—… íŒ¨í„´**: íŒ€ ê°„ ìƒí˜¸ì‘ìš© íŒ¨í„´

## ë¯¸ë˜ ë°œì „ ë°©í–¥

### AI í†µí•©
- **ë˜‘ë˜‘í•œ ì–´ì‹œìŠ¤í„´íŠ¸**: íšŒì˜ ì¼ì • ìë™ ì¡°ìœ¨
- **ìë™ ë²ˆì—­**: ì‹¤ì‹œê°„ ë‹¤êµ­ì–´ ë²ˆì—­
- **ê°ì • ì¸ì‹**: ëŒ€í™” ë§¥ë½ ì´í•´ ë° ì œì•ˆ
- **ì˜ˆì¸¡ ë¶„ì„**: íŒ€ í˜‘ì—… íš¨ìœ¨ì„± ì˜ˆì¸¡

### ì°¨ì„¸ëŒ€ ê¸°ìˆ 
- **AR/VR íšŒì˜**: ëª°ì…í˜• ê°€ìƒ íšŒì˜ì‹¤
- **í™€ë¡œê·¸ë¨**: 3D í”„ë ˆì  ìŠ¤ ê¸°ìˆ 
- **ë‡ŒíŒŒ ì¸í„°í˜ì´ìŠ¤**: ìƒê°ìœ¼ë¡œ ë©”ì‹œì§€ ì‘ì„±
- **ë¸”ë¡ì²´ì¸**: íƒˆì¤‘ì•™í™”ëœ í˜‘ì—… í”Œë«í¼